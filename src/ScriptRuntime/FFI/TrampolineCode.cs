/*
 * Copyright 2025 xy660
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace ScriptRuntime.FFI
{
    public static class TrampolineCode
    {
        public enum ABI
        {
            Undefined,
            Stdcall,
            Cdecl,
            Microsoft,
            SystemV
        }

        public static readonly byte[] cdecl_x86 = { 0x68, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x00, 0x00, 0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x01, 0x53, 0x56, 0x57, 0x8b, 0x5c, 0x24, 0x0c, 0x8d, 0x74, 0x24, 0x1c, 0x89, 0xcf, 0x83, 0xfb, 0x00, 0x0f, 0x84, 0x12, 0x00, 0x00, 0x00, 0x8b, 0x06, 0x89, 0x07, 0x83, 0xc6, 0x04, 0x83, 0xc7, 0x04, 0x83, 0xeb, 0x01, 0xe9, 0xe5, 0xff, 0xff, 0xff, 0x5f, 0x5e, 0x5b, 0x58, 0x5a, 0x58, 0x51, 0x52, 0xff, 0xd0, 0x5a, 0x59, 0xc3 };

        public static readonly byte[] stdcall_x86 = { 0x53, 0x56, 0x57, 0x68, 0x00, 0x00, 0x00, 0x01, 0xb9, 0x00, 0x00, 0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x01, 0x8b, 0x1c, 0x24, 0x8d, 0x74, 0x24, 0x1c, 0x89, 0xcf, 0x83, 0xfb, 0x00, 0x0f, 0x84, 0x12, 0x00, 0x00, 0x00, 0x8b, 0x06, 0x89, 0x07, 0x83, 0xc6, 0x04, 0x83, 0xc7, 0x04, 0x83, 0xeb, 0x01, 0xe9, 0xe5, 0xff, 0xff, 0xff, 0x5f, 0x5a, 0x58, 0x51, 0x52, 0xff, 0xd0, 0x5a, 0x59, 0x89, 0xfa, 0x5f, 0x5e, 0x5b, 0x59, 0x83, 0xfa, 0x00, 0x0f, 0x84, 0x08, 0x00, 0x00, 0x00, 0x83, 0xc4, 0x04, 0x83, 0xea, 0x01, 0xeb, 0xef, 0x51, 0xc3 };

        public static readonly byte[] microsoft_x64 = { 0x49, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x49, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x41, 0x54, 0x49, 0x89, 0x0b, 0x49, 0x89, 0x53, 0x08, 0x4d, 0x89, 0x43, 0x10, 0x4d, 0x89, 0x4b, 0x18, 0x4c, 0x8b, 0x64, 0x24, 0x28, 0x4d, 0x89, 0x63, 0x20, 0x4c, 0x8b, 0x64, 0x24, 0x30, 0x4d, 0x89, 0x63, 0x28, 0x4c, 0x8b, 0x64, 0x24, 0x38, 0x4d, 0x89, 0x63, 0x30, 0x4c, 0x8b, 0x64, 0x24, 0x40, 0x4d, 0x89, 0x63, 0x38, 0x4c, 0x8b, 0x64, 0x24, 0x48, 0x4d, 0x89, 0x63, 0x40, 0x4c, 0x8b, 0x64, 0x24, 0x50, 0x4d, 0x89, 0x63, 0x48, 0x4c, 0x8b, 0x64, 0x24, 0x58, 0x4d, 0x89, 0x63, 0x50, 0x4c, 0x8b, 0x64, 0x24, 0x60, 0x4d, 0x89, 0x63, 0x58, 0x48, 0x89, 0xc1, 0x4c, 0x89, 0xda, 0x41, 0x5c, 0x41, 0xff, 0xe2 };

        public static readonly byte[] system_v = { 0x49, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x49, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x41, 0x54, 0x49, 0x89, 0x3b, 0x49, 0x89, 0x73, 0x08, 0x49, 0x89, 0x53, 0x10, 0x49, 0x89, 0x4b, 0x18, 0x4d, 0x89, 0x43, 0x20, 0x4d, 0x89, 0x4b, 0x28, 0x4c, 0x8b, 0x64, 0x24, 0x10, 0x4d, 0x89, 0x63, 0x30, 0x4c, 0x8b, 0x64, 0x24, 0x18, 0x4d, 0x89, 0x63, 0x38, 0x4c, 0x8b, 0x64, 0x24, 0x20, 0x4d, 0x89, 0x63, 0x40, 0x4c, 0x8b, 0x64, 0x24, 0x28, 0x4d, 0x89, 0x63, 0x48, 0x4c, 0x8b, 0x64, 0x24, 0x30, 0x4d, 0x89, 0x63, 0x50, 0x4c, 0x8b, 0x64, 0x24, 0x38, 0x4d, 0x89, 0x63, 0x58, 0x48, 0x89, 0xc7, 0x4c, 0x89, 0xde, 0x41, 0x5c, 0x41, 0xff, 0xe2 };

        //动态修补跳板代码，根据平台自行选择
        //使用运行时动态判断，因为条件编译只有AOT有效，为了确保托管模式也能生效
        public static unsafe byte[] GenerateTrampoline(int funcId, int argCount, nint heapAddr, nint targetFunc, ABI abi)
        {

            if (abi == ABI.Undefined)
            {
                if (RuntimeInformation.ProcessArchitecture == Architecture.X64) //自动假设各个平台适合的ABI
                {
                    abi = OperatingSystem.IsWindows() ? ABI.Microsoft : ABI.SystemV;
                }
                else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
                {
                    abi = OperatingSystem.IsWindows() ? ABI.Stdcall : ABI.Cdecl;
                }
                else
                {
                    throw new NotImplementedException("此架构未实现Callback跳板代码生成");
                }
            }

            if (abi == ABI.Stdcall)
            {
                var bt = stdcall_x86.ToArray();
                fixed (byte* p = bt)
                {
                    *((nint*)(p + 4)) = targetFunc;
                    *((nint*)(p + 9)) = heapAddr;
                    *((nint*)(p + 14)) = funcId;
                    *((nint*)(p + 19)) = argCount;
                }
                return bt;
            }
            else if (abi == ABI.Cdecl)
            {
                var bt = cdecl_x86.ToArray();
                fixed (byte* p = bt)
                {
                    *((nint*)(p + 1)) = targetFunc;
                    *((nint*)(p + 6)) = heapAddr;
                    *((nint*)(p + 11)) = funcId;
                    *((nint*)(p + 16)) = argCount;
                }
                return bt;
            }
            else if (abi == ABI.Microsoft)
            {

                var bt = microsoft_x64.ToArray();
                fixed (byte* p = bt)
                {
                    *((nint*)(p + 2)) = targetFunc;
                    *((nint*)(p + 12)) = heapAddr;
                    *((nint*)(p + 22)) = funcId;
                }
                return bt;
            }
            else if (abi == ABI.SystemV)
            {
                var bt = system_v.ToArray();
                fixed (byte* p = bt)
                {
                    *((nint*)(p + 2)) = targetFunc;
                    *((nint*)(p + 12)) = heapAddr;
                    *((nint*)(p + 22)) = funcId;
                }
                return bt;
            }
            else
            {
                throw new NotImplementedException("此ABI暂不支持");
            }
        }
    }
}
